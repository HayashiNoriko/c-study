#include <stdio.h>

// 变量初始值、值溢出、常量、无符号数、类型转换

int main() {
    // 1、变量初始值
    int a, b, c, d;
    printf("%d,%d,%d,%d\n", a, b, c, d);
    // 81821496,1,81854464,1
    /**定义变量时我们没有为其设定初始值，那么它的值就是不确定的了，每次运行都不一样
    （千万注意，并不是不设定值默认就是0）*/


    // 2、值溢出
    char ch = 127;
    printf("%d\n", ch);
    // 127
    /**char类型的存储只有1字节，这里已经达到ch的最大值了*/

    ch++;
    printf("%d\n", ch);
    // -128
    /**127 + 1 = 01111111 + 1 = 10000000
    由于现在是二进制，满2进1，所以最后变成10000000
    10000000是补码，真值为 -128*/


    // 3、常量
    const int i = 10;
    // i++;
    /**会报错。常量在一开始设定初始值后，后续是不允许进行修改的*/


    // 4、无符号数
    unsigned char u = -65;
    printf("%u\n", u);
    // 191
    /**
     * u在内存中存储的形式是：10111111（-65的补码）
     这里既然将其以无符号数的形式输出，我们知道无符号数都是正数（最高位不是符号位，而是数值位）
     那么会将10111111按权值直接计算
     128 + 32 + 16 + 8 + 4 + 2 + 1 = 191
     * */

    /**133414
    3512414
    wweg*/

    char u2 = u;
    printf("%u\n", u2);
    // 4294967231
    /**
     * 和u一样，u2在内存中存储的形式是：10111111（-65的补码）
     在 printf 函数中，u 被整型提升为 int。由于 u 是有符号的，这个提升包括符号扩展
     这意味着 u 的高位（即左边的位）会用它的符号位（最高位，这里是 1）填充
     因此，u 在 32 位 int 中的表示会是 11111111 11111111 11111111 10111111。
     这个 32 位值以无符号整数格式打印，因此打印结果是 4294967231。
     实际上，第一段代码中，u也进行了整型提升，只不过u是无符号的，位数扩展时，高位用0填充
     即 00000000 00000000 00000000 10111111
     * */

    /**
     * 整型提升是 C 语言中的一个概念
     * 指的是在表达式求值过程中，较小的整型（如 char）会被转换为较大的整型（通常是 int）。
     * 这样做是为了提高运算效率和保证数值范围的统一。
     * 在大多数现代架构中，int 是 32 位的。
     * */


    // 5、类型转换
    float f = 2;
    int n = 3;
    double db = n / f;
    printf("%f", db);
    // 1.500000
    /**
    不同的类型优先级不同（根据长度而定）
    char和short类型在参与运算时一律转换为int再进行运算。
    浮点类型默认按双精度进行计算，所以就算有float类型，也会转换为double类型参与计算。
    当有一个更高优先级的类型和一个低优先级的类型同时参与运算时，统一转换为高优先级运算
    比如int和long参与运算，那么int转换为long再算，所以结果也是long类型
     int和double参与运算，那么先把int转换为double再算。
    */








    return 0;
}
